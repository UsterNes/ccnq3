#!/usr/bin/env coffee

NAME='ccnq3'
SRC="/opt/#{NAME}/src"

{ escape } = require 'querystring'
url = require 'url'
{ spawn } = require 'child_process'
crypto = require 'crypto'
{ inspect } = require 'util'

ccnq3 = require 'ccnq3'

default_apps = [
  "applications/monitor"
  "applications/host"
]

# This is the list of apps listed in debian/ccnq3-couchdb.postinst
manager_apps = [
  "applications/couch_daemon"
  "applications/provisioning"
  "applications/logging"
  "applications/cdrs"
  "applications/locations"
  "applications/voicemail-store"
]

# Set defaults, assuming _only_ locally-available information.
set_defaults = (prov_doc,hostname) ->
    # Common parameters
    prov_doc._id ?= ccnq3.make_id 'host', hostname
    prov_doc.type ?= 'host'
    prov_doc.host ?= hostname
    prov_doc.interfaces ?= {}
    prov_doc.applications ?= []

    prov_doc.account ?= ''
    prov_doc.updated_at ?= new Date().getTime()

    if prov_doc.admin?.system
      # --  Manager host  -- #
      for app in manager_apps
        unless app in prov_doc.applications
          prov_doc.applications.push app

      # This _has_ to be present on a Manager.
      admin_info = url.parse prov_doc.admin.couchdb_uri

      # Default auth info
      prov_doc.admin.auth ?= admin_info.auth

      # Default AMQP info
      vhost = NAME
      amqp_info =
        protocol: 'amqp'
        hostname: admin_info.hostname
        auth:     prov_doc.admin.auth
        pathname: '/' + escape vhost
        slashes:  true
      prov_doc.admin.amqp ?= url.format amqp_info

      # Default AMQP Management info
      amqp_mgmt =
        protocol: 'http'
        hostname: admin_info.hostname
        port:     55672
        auth:     prov_doc.admin.auth
        pathname: '/api'
      prov_doc.admin.amqp_mgmt ?= url.format amqp_mgmt

    for app in default_apps
      unless app in prov_doc.applications
        prov_doc.applications.push app

hex_sha1 = (v) ->
  crypto.createHash('sha1').update(v).digest('hex')

commands =
  'show log': ->
    ccnq3.amqp (c) ->
      c.queue 'cli', (q) ->
        q.bind 'logging', '#'
        q.subscribe (m) ->
          console.dir m
    return

  'get admin uri': ->
    ccnq3.config (config) ->
      base_uri = config.admin?.couchdb_uri
      if not base_uri?
        console.error 'Admin access is not available on this host.'
        return 1

      console.log "#{base_uri}/_utils/"
    return

  'create admin password': ->
    ccnq3.config (config) ->
      config.admin ?= {}
      if not config.admin.password?
        crypto.randomBytes 32, (e,buf) ->
          if e then throw e
          config.admin.password = buf.toString 'hex'
          ccnq3.config.update config
          console.log config.admin.password
      else
        console.log config.admin.password
      return

  'get name': ->
    console.log NAME
    return

  'get hostname': ->
    console.log require('os').hostname()
    return

  'get config location': ->
    console.log ccnq3.config.location
    return

  'get config source': ->
    ccnq3.config (config) ->
      if config.source
        SRC = config.source
      console.log SRC
    return

  ## -- Used on a manager during postinst -- ##
  'set admin uri': (uri) ->
    ccnq3.config (config) ->
      config.admin ?= {}
      config.admin.couchdb_uri = uri
      config.admin.system = true
      config.users ?= {}
      config.users.couchdb_uri ?= uri + '/_users'

      # Save
      ccnq3.config.update config
    return

  'set admin amqp': (uri) ->
    ccnq3.config (config) ->
      config.admin ?= {}
      config.admin.amqp = uri

      # Save
      ccnq3.config.update config
    return

  ## -- Used on a client during postinst -- ##
  'set host uri': (uri) ->
    if not uri?
      console.error 'URI parameter is required.'
      return 1

    ccnq3.config (config) ->
      config.provisioning ?= {}
      config.provisioning.host_couchdb_uri = uri

      info = url.parse uri
      # Default auth info
      config.auth ?= info.auth
      # Default AMQP info
      vhost = NAME
      amqp_info =
        protocol: 'amqp'
        hostname: info.hostname
        auth: config.auth
        pathname: '/' + escape vhost
      config.amqp ?= url.format amqp_info

      # Save
      ccnq3.config.update config
    return

  'set local uri': (uri) ->
    if not uri?
      console.error 'URI parameter is required.'
      return 1

    ccnq3.config (config) ->
      config.provisioning ?= {}
      config.provisioning.local_couchdb_uri = uri

      # Save
      ccnq3.config.update config
    return

  'set local defaults': ->
    ccnq3.config (config) ->
      if config.source
        SRC = config.source
      process.chdir SRC

      HOSTNAME = require('os').hostname()

      # Common parameters
      config.source ?= SRC
      config.interfaces ?= require('./interfaces')()

      set_defaults config, HOSTNAME

      # Save
      ccnq3.config.update config
    return

  'add local service': (name) ->
    ccnq3.config (config) ->
      if config.source
        SRC = config.source
      process.chdir SRC

      config.applications ?= []
      unless name in config.applications
        config.applications.push name

      ccnq3.config.update config

  'add user': (name,password) ->
    ccnq3.config (config) ->
      if config.source
        SRC = config.source
      process.chdir SRC

      if not config.users?.couchdb_uri?
        console.error 'Users access is not available on this host.'
        return

      ccnq3.db.add_user config.users.couchdb_uri, name, password, (e) ->
        if e
          console.error "Could not update the user record: #{inspect e}"
        else
          console.warn 'User account was updated successfully.'
    return

  'admin': (name) ->
    ccnq3.config (config) ->
      if config.source
        SRC = config.source
      process.chdir SRC

      if not config.users?.couchdb_uri?
        console.error 'Users access is not available on this host.'
        return

      admin_access = [
        "access:provisioning:"  # Pull provisioning database
        "update:provisioning:"  # Push provisioning database
        "update:_users:"        # Allows to create user records
        "update:_users:"        # Allows to grant the role (via applications/roles/zappa/admin.coffee)
        "update:host:"          # Role to add and modify hosts (servers)
        "update:user_db:"       # Allows to grant this role to new "voicemail@" accounts. (Not required if not using voicemail.)
        "access:_users:"        # Allows to grant this role to new "voicemail@" accounts. (Not required if not using voicemail.)
        "access:traces:"        # Allows to grant the role to users who need to gather sniffer traces
      ]

      ccnq3.db.add_roles config.users.couchdb_uri, name, admin_access, (e) ->
        if e
          console.error "Could not update the user record: #{inspect e}"
        else
          console.warn 'User account was updated successfully.'
    return

  'add host': (hostname) ->
    if not hostname?
      console.error 'Hostname is required.'
      return 1

    ccnq3.config (config) ->
      if config.source
        SRC = config.source
      process.chdir SRC

      if not config.admin?.couchdb_uri?
        console.error 'CouchDB admin access is not available on this host.'
        return

      if not config.admin?.amqp_mgmt?
        console.error 'AMQP admin access is not available on this host.'
        return

      if not config.users?.couchdb_uri?
        console.error 'Users access is not available on this host.'
        return

      if not config.provisioning?.couchdb_uri?
        console.error 'Provisioning acces is not available on this host.'
        return

      pico = require 'pico'

      # Take care of the setup in the _users database.
      user_db = pico config.users.couchdb_uri
      host_user = 'host@' + hostname
      user_db.get_user host_user, (e,r,user_doc) ->
        new_password = null
        if e or not user_doc._rev?
          console.log "Assuming user #{host_user} wasn't registered."
          new_password = hex_sha1 "a"+Math.random()
          user_doc =
            name: host_user
            password: new_password

        user_doc.roles ?= []
        user_doc.roles.push 'host' unless 'host' in user_doc.roles

        user_db.put_user user_doc, (e) ->
          if e
            console.error inspect e
            process.exit 1

        # Take care of the setup in the provisioning database.
        _id = ccnq3.make_id 'host', hostname
        prov_db = pico config.provisioning.couchdb_uri
        prov_db.get _id, (e,r,prov_doc) ->
          unless prov_doc?._rev?
            console.log "Assuming new record for _id #{_id} (#{inspect e})"
            prov_doc = { _id }

          make_host_uri = (cdb_uri,pathname) ->
            cdb_info = url.parse cdb_uri
            host_info =
              protocol: cdb_info.protocol
              auth:     prov_doc.auth
              hostname: cdb_info.hostnane
              port:     cdb_info.port
              pathname: cdb_info.pathname ? pathname
            url.format host_info

          # --  Compute new prov_doc.auth  --

          if new_password?
            prov_doc.password = new_password  # legacy
            prov_doc.auth = host_user + ':' + new_password
            # FIXME This will go very bad if prov_doc.provisioning.host_couchdb_uri, etc.
            # already exist. We really ought to update all those records.

          # Former code used `password` only. Really we need both fields, it's so much
          # simpler to deal with. So migrate the record.
          if prov_doc.password? and not prov_doc.auth?
            prov_doc.auth = host_user + ':' + prov_doc.password
            # FIXME Same as above, there's no obligation that the URIs match.
            # At least we should indicate that there's a discrepancy.

          # The Official Way: export from provisioning.host_couchdb_uri.
          if not prov_doc.password? and not prov_doc.auth? and prov_doc?.provisioning?.host_couchdb_uri?
            prov_info = url.parse prov_doc.provisioning.host_couchdb_uri
            prov_doc.auth = prov_info.auth
            # This will break happily if you use ':' in your passwords.
            # So stick to our automagically-generated SHA1 passwords.
            prov_doc.password = prov_doc.auth.split(/:/)[1]

          set_defaults prov_doc, hostname

          prov_doc.provisioning ?= {}

          prov_doc.provisioning.host_couchdb_uri ?= make_host_uri config.admin.couchdb_uri

          # Default AMQP info
          prov_info = url.parse prov_doc.provisioning.host_couchdb_uri
          vhost = NAME
          amqp_info =
            protocol: 'amqp'
            hostname: prov_info.hostname
            auth:     prov_doc.auth
            pathname: '/' + escape vhost
          config.amqp ?= url.format amqp_info

          prov_doc.logging ?= {}

          prov_doc.logging.host_couchdb_uri ?=
            if config.logging?.host_couchdb_uri?
              make_host_uri config.logging.host_couchdb_uri
            else
              make_host_uri config.admin.couchdb_uri, '/logging'

          prov_doc.monitor ?= {}

          prov_doc.monitor.host_couchdb_uri ?=
            if config.monitor?.host_couchdb_uri?
              make_host_uri config.monitor.host_couchdb_uri
            else
              make_host_uri config.admin.couchdb_uri, '/monitor'

          prov_doc.provisioning.local_couchdb_uri ?= 'http://127.0.0.1:5984/provisioning'

          # save in provisioning db
          prov_db.put prov_doc, (e,r) ->
            if e?
              console.error "Could not create record for _id #{_id}: #{inspect e}"
              process.exit 1

          # Register with RabbitMQ
          amqp_mgmt = pico.request config.admin.amqp_mgmt

          amqp_user_info =
            password: prov_doc.password
            tags: ""
          amqp_mgmt.put "/users/#{escape host_user}", json:amqp_user_info, (e,r) ->
            if e?
              console.error "Could not create AMQP user: #{inspect e}"
              process.exit 1
            unless 200 <= r.statusCode < 300
              console.error "Could not create AMQP user: #{r.statusCode}"
              process.exit 1
            # FIXME get the vhost from the amqp URI.
            user_vhost = NAME
            amqp_permissions =
              configure: ".*"
              write: ".*"
              read: ".*"
            amqp_mgmt.put "/permissions/#{escape user_vhost}/#{escape host_user}", json:amqp_permissions, (e,r) ->
              unless 200 <= r.statusCode < 300
                console.error "Could not create AMQP user: #{inspect e}"
                process.exit 1
    return


run = ->

  command = process.argv[2]
  args = process.argv.slice 3

  if not command?
    console.info "Available commands:"
    for c of commands
      console.info "  #{c}"
    return 1

  command = command.replace /_/g, ' '
  if commands[command]?
    commands[command] args...
  else
    console.error "Unknown command #{command}"
    return 1

sync_exit = run()
if sync_exit?
  process.exit sync_exit
