# authenticate.cfg -- authenticate INVITE or REGISTER
# Copyright (C) 2009  Stephane Alnet
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

define need_avp_db

route[authenticate] {
  if( if has_trusted allow_trusted() || end if has_trusted 0 ) {
    # peer_tag_avp contains more information about this (trusted) endpoint
    $(avp(forwarding_sbc)) = $(avp(peer_context_info));

    # If the source IP is a trusted SBC then they must provide us with a Sock-Info header,
    # similar to one we would get by doing a   add_sock_hdr("Sock-Info") ,
    # or with a RURI parameter "source" that contains the IP address of the actual originator.
    if($(avp(forwarding_sbc)) == "1") {
      xlog("L_DBG","DEBUG -- route(authenticate): Forwarding SBC $si, trying header Sock-Info = $(hdr(Sock-Info))");
      $avp(host_info) = $(hdr(Sock-Info){uri.host});
      if(!$avp(host_info)) {
        xlog("L_DBG","DEBUG -- route(authenticate): Forwarding SBC $si, trying URI param source = $(ru{uri.param,source})");
        $avp(host_info) = $(ru{uri.param,source}); # See client-ocs-sbc.
      }
      route(authenticate_check); # Authenticate customer
    }
  } else {
    xlog("L_DBG","DEBUG -- route(authenticate): Using socket source IP = $si");
    $avp(host_info) = $si;
    route(authenticate_check); # Authenticate customer
  }
}

# -----------------------------------------------------------------
# UAC Authentication (customer-side, "untrusted")
# -----------------------------------------------------------------

route[authenticate_check] {
    xlog("L_DBG","DEBUG -- route(authenticate_check): Customer device from $si");

    # Check whether this is a customer-side trunk (S2S).
    if(!avp_db_load("$avp(host_info)","$(avp(src_subs))")) {
      xlog("L_DBG","DEBUG -- route(authenticate): Authorizing source $si");

      if (!check_from()) {
          sl_send_reply("403", "Use From=Authentication-ID");
          exit;
      }

      if authentication is radius
        if (!radius_proxy_authorize("${challenge}")) {
          proxy_challenge("${challenge}","0");
          exit;
        }
      end if authentication is radius

      if authentication is database
        if (!proxy_authorize("${challenge}","subscriber")) {
          $var(code) = $retcode;
          xlog("L_DBG","DEBUG -- route(authenticate): proxy_authorize failed: $var(code)");
          proxy_challenge("${challenge}","0");
          exit;
        }
      end if authentication is database

      consume_credentials();

      $(avp(src_subs)) = $fU;
    }

    xlog("L_DBG","DEBUG -- route(authenticate): Customer device $(avp(src_subs)) with account $(avp(account)).");
}

route[authenticate_register] {
  xlog("L_DBG","DEBUG -- route(authenticate_register): Customer device from $si");

  if authentication is radius
    if (!radius_www_authorize("${challenge}")) {
      xlog("L_DBG", "route(register-handler) -- Device $si ($fu) failed to register");
      www_challenge("${challenge}","0");
      exit;
    }
  end if authentication is radius

  if authentication is database
    if (!www_authorize("${challenge}","subscriber")) {
      xlog("L_DBG", "route(register-handler) -- Device $si ($fu) failed to register");
      www_challenge("${challenge}","0");
      exit;
    };
  end if authentication is database

  consume_credentials();

}
