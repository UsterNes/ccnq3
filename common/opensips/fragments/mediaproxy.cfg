# mediaproxy.cfg -- handler for MediaProxy (SDP with NAT)
# Copyright (C) 2009  Stephane Alnet
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Media Proxy / RTP Proxy handling
# -----------------------------------------------------------------

route[start-media-proxy]
{
  xlog("L_DBG","DEBUG -- start-media-proxy -- Start Media Proxy");

  if not mp_allowed
    xlog("L_DBG","DEBUG -- start-media-proxy -- Media Proxy is not allowed.");
    return;
  end if not mp_allowed

  if mp_allowed
    if( use_media_proxy() ) {
      xlog("L_DBG","DEBUG -- start-media-proxy -- media_proxy OK");
      setbflag(8);
      setflag(8);
    } else {
      xlog("L_DBG","DEBUG -- start-media-proxy -- media_proxy failed or not needed");
    }
  end if mp_allowed
}

route[stop-media-proxy]
{
  xlog("L_DBG","DEBUG -- stop-media-proxy -- Tear down Proxy");

  if not mp_allowed
    xlog("L_DBG","DEBUG -- stop-media-proxy -- Media proxy is not allowed.");
    return;
  end if not mp_allowed

  if mp_allowed
    if(isflagset(8) || isbflagset(8)) {
      end_media_session();
      resetbflag(8);
      resetflag(8);
    }
  end if mp_allowed
}

# -----------------------------------------------------------------
# Reply-codes handler for NAT traversal
# -----------------------------------------------------------------

route[media-proxy-reply-handler] # Reply handler for MediaProxy
{
    # Update the mediaproxy information if needed.
    if(t_check_status("180|183|2[0-9][0-9]")) {
        route(update-media-proxy);  # Update media session
    }
    # Don't tear-down on error, we might fail over.
}

# -----------------------------------------------------------------
# A RURI may contain a "mp=yes" param to force usage of MP
# Note: This is independent from having mp=yes added to Record-Route
# params (and provided back by endpoints in Route params).
# -----------------------------------------------------------------

route[media-proxy-in-ruri]
{
  xlog("L_DBG","DEBUG -- media-proxy-in-ruri -- Detect MediaProxy request in RURI");
  # If the URI contains ";mp=yes" then force MediaProxy.
  if($(ru{uri.param,mp}) == "yes") {
    xlog("L_DBG","DEBUG -- media-proxy-in-ruri -- MediaProxy requested in RURI");
    setflag(6); # force MP for callee
    add_rr_param(";mp=yes");
  }
}

route[update-media-proxy]
{
  xlog("L_DBG","DEBUG -- route(update-media-proxy) -- Start Media Proxy if needed");

  if( check_route_param("mp=yes") ) {
    xlog("L_DBG","DEBUG -- route(update-media-proxy) -- Route indicates MP was activated");
    setflag(7);
  }

  if( ${mp_always} ||
      isbflagset(8) || isflagset(8) ||                # Update the existing mediaproxy session
      isflagset(6) || isbflagset(6) || isflagset(7)   # None exist, but one is needed
    )
  {
    if( search("^Content-Length:")
        && !search("^Content-Length:[ ]*0")
      ) {
      route(start-media-proxy);
    } else {
      xlog("L_DBG","DEBUG -- route(update-media-proxy) -- Media Proxy required but no SDP found");
    }
  } else {
    xlog("L_DBG","DEBUG -- route(update-media-proxy) -- Skipping Media Proxy");
  }
}
